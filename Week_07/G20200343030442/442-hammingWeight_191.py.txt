#--*--encoding:utf-8--*--
"""
Algorithm_hammingWeight_191.PY

解题思路：

这种方法速度比较快，其运算次数与输入n的大小无关，只与n中1的个数有关。如果n的二进制表示中有k个1，那么这个方法只需要循环k次即可。其原理是不断清除n的二进制表示中最右边的1，同时累加计数器，直至n为0
为什么n &= (n – 1)能清除最右边的1呢？因为从二进制的角度讲，n相当于在n - 1的最低位加上1。举个例子，8（1000）= 7（0111）+ 1（0001），所以8 & 7 = （1000）&（0111）= 0（0000），清除了8最右边的1（其实就是最高位的1，因为8的二进制中只有一个1）。再比如7（0111）= 6（0110）+ 1（0001），所以7 & 6 = （0111）&（0110）= 6（0110），清除了7的二进制表示中最右边的1（也就是最低位的1）
首先在Python中可以通过以"0b"或者"-0b"开头的字符串来表示二进制
"""
class Solution:
    def hammingWeight(self,n):
        count = 0
        while n != 0:
            # print(n)
            n &= (n - 1)
            count += 1
        return count

p = Solution()
print(p.hammingWeight(0b1111111111))


class Solution(object):
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        return bin(n).count('1')


p = Solution()
print(p.hammingWeight(0b1111111111))